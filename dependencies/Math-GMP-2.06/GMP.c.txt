/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of GMP.xs. Do not edit this file, edit GMP.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "GMP.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "gmp.h"

/*
Math::GMP, a Perl module for high-speed arbitrary size integer
calculations
Copyright (C) 2000 James H. Turner

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the Free
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

You can contact the author at chip@redhat.com, chipt@cpan.org, or by mail:

Chip Turner
Red Hat Inc.
2600 Meridian Park Blvd
Durham, NC 27713
*/

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}


#line 65 "GMP.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 117 "GMP.c"

XS(XS_Math__GMP_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_new_from_scalar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_new_from_scalar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	char *	s = (char *)SvPV_nolen(ST(0));
	mpz_t *	RETVAL;
#line 69 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init_set_str(*RETVAL, s, 0);
#line 158 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_new_from_scalar_with_base); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_new_from_scalar_with_base)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, b");
    {
	char *	s = (char *)SvPV_nolen(ST(0));
	int	b = (int)SvIV(ST(1));
	mpz_t *	RETVAL;
#line 80 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init_set_str(*RETVAL, s, b);
#line 183 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	mpz_t *	n;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 90 "GMP.xs"
    mpz_clear(*n);
    free(n);
#line 213 "GMP.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Math__GMP_stringify_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_stringify_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	mpz_t *	n;
#line 98 "GMP.xs"
    int len;

#line 234 "GMP.c"
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 101 "GMP.xs"
    len = mpz_sizeinbase(*n, 10);
    {
      char *buf;
      buf = malloc(len + 2);
      mpz_get_str(buf, 10, *n);
      RETVAL = newSVpv(buf, strlen(buf));
      free(buf);
    }
#line 252 "GMP.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_get_str_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_get_str_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "n, b");
    {
	mpz_t *	n;
	int	b = (int)SvIV(ST(1));
#line 119 "GMP.xs"
    int len;

#line 276 "GMP.c"
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 122 "GMP.xs"
    len = mpz_sizeinbase(*n, b);
    {
        char *buf;
        buf = malloc(len + 2);
        mpz_get_str(buf, b, *n);
        RETVAL = newSVpv(buf, strlen(buf));
        free(buf);
    }
#line 294 "GMP.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_sizeinbase_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_sizeinbase_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "n, b");
    {
	mpz_t *	n;
	int	b = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 139 "GMP.xs"
    RETVAL = mpz_sizeinbase(*n, b);
#line 326 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_uintify_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_uintify_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	mpz_t *	n;
	unsigned long	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 148 "GMP.xs"
    RETVAL = mpz_get_ui(*n);
#line 356 "GMP.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_add_ui_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_add_ui_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "n, v");
    {
	mpz_t *	n;
	unsigned long	v = (unsigned long)SvUV(ST(1));

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 158 "GMP.xs"
    mpz_add_ui(*n, *n, v);
#line 385 "GMP.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Math__GMP_intify_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_intify_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	mpz_t *	n;
	long	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 166 "GMP.xs"
    RETVAL = mpz_get_si(*n);
#line 414 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_mul_2exp_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_mul_2exp_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "n, e");
    {
	mpz_t *	n;
	unsigned long	e = (unsigned long)SvUV(ST(1));
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 176 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_mul_2exp(*RETVAL, *n, e);
#line 446 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_div_2exp_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_div_2exp_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "n, e");
    {
	mpz_t *	n;
	unsigned long	e = (unsigned long)SvUV(ST(1));
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 188 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_div_2exp(*RETVAL, *n, e);
#line 479 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_powm_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_powm_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "n, exp, mod");
    {
	mpz_t *	n;
	mpz_t *	exp;
	mpz_t *	mod;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            exp = (mpz_t *) tmp;
        }
        else
            croak("exp is not of type Math::GMP");

        if (sv_derived_from(ST(2), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(2)));
            mod = (mpz_t *) tmp;
        }
        else
            croak("mod is not of type Math::GMP");
#line 202 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_powm(*RETVAL, *n, *exp, *mod);
#line 527 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_mmod_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_mmod_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "a, b");
    {
	mpz_t *	a;
	mpz_t *	b;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            a = (mpz_t *) tmp;
        }
        else
            croak("a is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            b = (mpz_t *) tmp;
        }
        else
            croak("b is not of type Math::GMP");
#line 215 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_mmod(*RETVAL, *a, *b);
#line 567 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_mod_2exp_gmp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_mod_2exp_gmp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "in, cnt");
    {
	mpz_t *	in;
	unsigned long	cnt = (unsigned long)SvUV(ST(1));
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            in = (mpz_t *) tmp;
        }
        else
            croak("in is not of type Math::GMP");
#line 228 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_mod_2exp(*RETVAL, *in, cnt);
#line 600 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_add_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_add_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 241 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_add(*RETVAL, *m, *n);
#line 640 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_sub_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_sub_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 254 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_sub(*RETVAL, *m, *n);
#line 680 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_mul_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_mul_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 267 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_mul(*RETVAL, *m, *n);
#line 720 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_div_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_div_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 280 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_div(*RETVAL, *m, *n);
#line 760 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_bdiv_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_bdiv_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	mpz_t *	m;
	mpz_t *	n;
#line 293 "GMP.xs"
    mpz_t * quo;
    mpz_t * rem;
#line 786 "GMP.c"

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 296 "GMP.xs"
    quo = malloc (sizeof(mpz_t));
    rem = malloc (sizeof(mpz_t));
    mpz_init(*quo);
    mpz_init(*rem);
    mpz_tdiv_qr(*quo, *rem, *m, *n);
  EXTEND(SP, 2);
  PUSHs(sv_setref_pv(sv_newmortal(), "Math::GMP", (void*)quo));
  PUSHs(sv_setref_pv(sv_newmortal(), "Math::GMP", (void*)rem));
#line 810 "GMP.c"
	PUTBACK;
	return;
    }
}


XS(XS_Math__GMP_mod_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_mod_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 313 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_mod(*RETVAL, *m, *n);
#line 849 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_cmp_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_cmp_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 326 "GMP.xs"
    RETVAL = mpz_cmp(*m, *n);
#line 888 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_legendre); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_legendre)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 336 "GMP.xs"
    RETVAL = mpz_legendre(*m, *n);
#line 926 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_jacobi); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_jacobi)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 346 "GMP.xs"
    RETVAL = mpz_jacobi(*m, *n);
#line 964 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_probab_prime); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_probab_prime)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, reps");
    {
	mpz_t *	m;
	int	reps = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");
#line 356 "GMP.xs"
        RETVAL = mpz_probab_prime_p(*m, reps);
#line 995 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_pow_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_pow_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	long	n = (long)SvIV(ST(1));
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");
#line 366 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
/*    fprintf(stderr, "n is %ld\n", n);*/
    mpz_pow_ui(*RETVAL, *m, n);
#line 1028 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gcd_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gcd_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 380 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_gcd(*RETVAL, *m, *n);
#line 1068 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_fib); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_fib)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	long	n = (long)SvIV(ST(0));
	mpz_t *	RETVAL;
#line 392 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_fib_ui(*RETVAL, n);
#line 1093 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_and_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_and_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 405 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_and(*RETVAL, *m, *n);
#line 1133 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_xor_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_xor_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 417 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_xor(*RETVAL, *m, *n);
#line 1173 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_or_two); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_or_two)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	mpz_t *	n;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");

        if (sv_derived_from(ST(1), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(1)));
            n = (mpz_t *) tmp;
        }
        else
            croak("n is not of type Math::GMP");
#line 430 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_ior(*RETVAL, *m, *n);
#line 1213 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_fac); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_fac)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	long	n = (long)SvIV(ST(0));
	mpz_t *	RETVAL;
#line 442 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_fac_ui(*RETVAL, n);
#line 1238 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "m");
    {
	mpz_t *	m;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");
#line 454 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init_set(*RETVAL, *m);
#line 1269 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_tstbit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_tstbit)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "m, n");
    {
	mpz_t *	m;
	long	n = (long)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");
#line 465 "GMP.xs"
    RETVAL = mpz_tstbit(*m,n);
#line 1301 "GMP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__GMP_gmp_sqrt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__GMP_gmp_sqrt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "m");
    {
	mpz_t *	m;
	mpz_t *	RETVAL;

        if (sv_derived_from(ST(0), "Math::GMP")) {
            IV tmp = SvIV((SV*)SvRV(ST(0)));
            m = (mpz_t *) tmp;
        }
        else
            croak("m is not of type Math::GMP");
#line 474 "GMP.xs"
    RETVAL = malloc (sizeof(mpz_t));
    mpz_init(*RETVAL);
    mpz_sqrt(*RETVAL, *m);
#line 1332 "GMP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Math::GMP", (void*)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Math__GMP); /* prototype to pass -Wmissing-prototypes */
XS(boot_Math__GMP)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Math::GMP::constant", XS_Math__GMP_constant, file, "$$");
        (void)newXSproto_portable("Math::GMP::new_from_scalar", XS_Math__GMP_new_from_scalar, file, "$");
        (void)newXSproto_portable("Math::GMP::new_from_scalar_with_base", XS_Math__GMP_new_from_scalar_with_base, file, "$$");
        (void)newXSproto_portable("Math::GMP::destroy", XS_Math__GMP_destroy, file, "$");
        (void)newXSproto_portable("Math::GMP::stringify_gmp", XS_Math__GMP_stringify_gmp, file, "$");
        (void)newXSproto_portable("Math::GMP::get_str_gmp", XS_Math__GMP_get_str_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::sizeinbase_gmp", XS_Math__GMP_sizeinbase_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::uintify_gmp", XS_Math__GMP_uintify_gmp, file, "$");
        (void)newXSproto_portable("Math::GMP::add_ui_gmp", XS_Math__GMP_add_ui_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::intify_gmp", XS_Math__GMP_intify_gmp, file, "$");
        (void)newXSproto_portable("Math::GMP::mul_2exp_gmp", XS_Math__GMP_mul_2exp_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::div_2exp_gmp", XS_Math__GMP_div_2exp_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::powm_gmp", XS_Math__GMP_powm_gmp, file, "$$$");
        (void)newXSproto_portable("Math::GMP::mmod_gmp", XS_Math__GMP_mmod_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::mod_2exp_gmp", XS_Math__GMP_mod_2exp_gmp, file, "$$");
        (void)newXSproto_portable("Math::GMP::add_two", XS_Math__GMP_add_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::sub_two", XS_Math__GMP_sub_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::mul_two", XS_Math__GMP_mul_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::div_two", XS_Math__GMP_div_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::bdiv_two", XS_Math__GMP_bdiv_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::mod_two", XS_Math__GMP_mod_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::cmp_two", XS_Math__GMP_cmp_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_legendre", XS_Math__GMP_gmp_legendre, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_jacobi", XS_Math__GMP_gmp_jacobi, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_probab_prime", XS_Math__GMP_gmp_probab_prime, file, "$$");
        (void)newXSproto_portable("Math::GMP::pow_two", XS_Math__GMP_pow_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::gcd_two", XS_Math__GMP_gcd_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_fib", XS_Math__GMP_gmp_fib, file, "$");
        (void)newXSproto_portable("Math::GMP::and_two", XS_Math__GMP_and_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::xor_two", XS_Math__GMP_xor_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::or_two", XS_Math__GMP_or_two, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_fac", XS_Math__GMP_gmp_fac, file, "$");
        (void)newXSproto_portable("Math::GMP::gmp_copy", XS_Math__GMP_gmp_copy, file, "$");
        (void)newXSproto_portable("Math::GMP::gmp_tstbit", XS_Math__GMP_gmp_tstbit, file, "$$");
        (void)newXSproto_portable("Math::GMP::gmp_sqrt", XS_Math__GMP_gmp_sqrt, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

