.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::GMP 3"
.TH Math::GMP 3 "2009-09-17" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::GMP \- High speed arbitrary size integer math
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::GMP;
\&  my $n = new Math::GMP 2;
\&
\&  $n = $n ** (256*1024);
\&  $n = $n \- 1;
\&  print "n is now $n\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Math::GMP was designed to be a drop-in replacement both for
Math::BigInt and for regular integer arithmetic.  Unlike BigInt,
though, Math::GMP uses the \s-1GNU\s0 gmp library for all of its
calculations, as opposed to straight Perl functions.  This can result
in speed improvements.
.PP
The downside is that this module requires a C compiler to install \*(-- a
small tradeoff in most cases. Also, this module is not 100% compatible
to Math::BigInt.
.PP
A Math::GMP object can be used just as a normal numeric scalar would
be \*(-- the module overloads most of the normal arithmetic operators to
provide as seamless an interface as possible. However, if you need a
perfect interface, you can do the following:
.PP
.Vb 1
\&  use Math::GMP qw(:constant);
\&
\&  $n = 2 ** (256 * 1024);
\&  print "n is $n\en";
.Ve
.PP
This would fail without the ':constant' since Perl would use normal
doubles to compute the 250,000 bit number, and thereby overflow it
into meaninglessness (smaller exponents yield less accurate data due
to floating point rounding).
.SH "METHODS"
.IX Header "METHODS"
Although the non-overload interface is not complete, the following
functions do exist:
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $x = Math::GMP\->new(123);
.Ve
.PP
Creates a new Math::GMP object from the passed string or scalar.
.PP
.Vb 1
\&  $x = Math::GMP\->new(\*(Aqabcd\*(Aq, 36);
.Ve
.PP
Creates a new Math::GMP object from the first parameter which should
be represented in the base specified by the second parameter.
.SS "bfac"
.IX Subsection "bfac"
.Vb 2
\&  $x = Math::GMP\->new(5);
\&  $x\->bfac();      # 1*2*3*4*5 = 120
.Ve
.PP
Calculates the factorial of \f(CW$x\fR and modifies \f(CW$x\fR to contain the result.
.SS "band"
.IX Subsection "band"
.Vb 2
\&  $x = Math::GMP\->new(6);
\&  $x\->band(3);      # 0b110 & 0b11 = 1
.Ve
.PP
Calculates the bit-wise \s-1AND\s0 of it's two arguments and modifies the first
argument.
.SS "bxor"
.IX Subsection "bxor"
.Vb 2
\&  $x = Math::GMP\->new(6);
\&  $x\->bxor(3);      # 0b110 & 0b11 = 0b101
.Ve
.PP
Calculates the bit-wise \s-1XOR\s0 of it's two arguments and modifies the first
argument.
.SS "bior"
.IX Subsection "bior"
.Vb 2
\&  $x = Math::GMP\->new(6);
\&  $x\->bior(3);      # 0b110 & 0b11 = 0b111
.Ve
.PP
Calculates the bit-wise \s-1OR\s0 of it's two arguments and modifies the first
argument.
.SS "bgcd"
.IX Subsection "bgcd"
.Vb 2
\&  $x = Math::GMP\->new(6);
\&  $x\->bgcd(4);      # 6 / 2 = 2, 4 / 2 = 2 => 2
.Ve
.PP
Calculates the Greatest Common Divisior of it's two arguments and returns the result.
.SS "legendre"
.IX Subsection "legendre"
.SS "jacobi"
.IX Subsection "jacobi"
.SS "fibonacci"
.IX Subsection "fibonacci"
.Vb 1
\&  $x = Math::GMP\->fibonacci(16);
.Ve
.PP
Calculates the n'th number in the Fibonacci sequence.
.SS "probab_prime"
.IX Subsection "probab_prime"
.Vb 2
\&  $x = Math::GMP\->new(7);
\&  $x\->probab_prime(10);
.Ve
.PP
Probabilistically Determines if the number is a prime. Argument is the number
of checks to perform. Returns 0 if the number is definitely not a prime,
1 if it may be, and 2 if it is definitely is a prime.
.SH "BUGS"
.IX Header "BUGS"
As of version 1.0, Math::GMP is mostly compatible with the old
Math::BigInt version. It is not a full replacement for the rewritten
Math::BigInt versions, though. See the \s-1SEE\s0 \s-1ALSO\s0 section
on how to achieve to use Math::GMP and retain full compatibility to
Math::BigInt.
.PP
There are some slight incompatibilities, such as output of positive
numbers not being prefixed by a '+' sign.  This is intentional.
.PP
There are also some things missing, and not everything might work as
expected.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigInt has a new interface to use a different library than the
default pure Perl implementation. You can use, for instance, Math::GMP
with it:
.PP
.Vb 1
\&  use Math::BigInt lib => \*(AqGMP\*(Aq;
.Ve
.PP
If Math::GMP is not installed, it will fall back to it's own Perl
implementation.
.PP
See Math::BigInt and Math::BigInt::GMP or
Math::BigInt::Pari or Math::BigInt::BitVect.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chip Turner <chip@redhat.com>, based on the old Math::BigInt by Mark Biggar
and Ilya Zakharevich.  Further extensive work provided by Tels 
<tels@bloodgate.com>.
